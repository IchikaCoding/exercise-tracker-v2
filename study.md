# 関数とスコープ

## 学び

- 関数定義
  - 変数の範囲を定義することとも言える

## 目的

- スコープについて理解する
- 新しい仕組みメインでやる

## わからないこと

- 別の関数で同じ変数を const で宣言すると SyntaxError
- 文と式

### ブロックスコープ

- 変数名が`name`だとスコープ外で実行したのに ReferenceError が出なかった
- ブラウザ環境ではグローバルに name という既存プロパティ（window.name）があるから
- ちなみに `let/const` でローカルに宣言する場合は，そのスコープ内では上書きされるよ
- if 文や while 文などもブロックスコープ
- for 文は、ループごとに新しいブロックスコープを作成

### スコープチェーン

- スコープチェーンとは？
  - 内側から外側のスコープへと順番に変数が定義されているか探す仕組みのこと
- スコープがネストしている場合に、内側のスコープから外側のスコープにある変数を参照できる

### グローバルスコープ

- これもスコープチェーンの仕組みにより、最終的にもっとも外側のグローバルスコープに定義されている変数を参照できる
- **変数の隠蔽**
  - 内側のスコープで外側のスコープと同じ名前の変数を定義することで、外側の変数が参照できなくなること
- 回避する方法としては、むやみにグローバルスコープへ変数を定義しないこと
- 小さなスコープ中心で書けば，影響範囲を小さくできる ♪
- 特定の変数を参照できる範囲を小さくするのはよいこと

### 関数スコープと var の巻き上げ

- 宣言部分がもっとも近い関数またはグローバルスコープの先頭に移動しているように見える動作のことを変数の巻き上げ
- （hoisting）

### 関数宣言と巻き上げ

- function を使った関数宣言も var と同様
- もっとも近い関数またはグローバルスコープの先頭に巻き上げられる
- 関数宣言は宣言そのものだからスコープの先頭に巻き上げられるよ ♪

### クロージャー

### 静的スコープ

- 静的スコープとは？
  - どの識別子がどの変数を参照しているかを静的に決定する性質のこと
  - 関数を実行する場所によってどの変数を参照するか，が変わらないよ！
  - 実行前に決まるから静的、実行時に決まるから動的

```js
const x = 10; // ＊1

function printX() {
  // この識別子`x`は常に ＊1 の変数`x`を参照する
  console.log(x); // => 10
}

function run() {
  const x = 20; // ＊2
  printX(); // 常に10が出力される
}

run();
```

- 常に 10 になるのはどうして？
  - スコープチェーンの仕組みを思い出しましょう ♡
  - 静的スコープの仕組みは function キーワードを使った関数宣言、メソッド、Arrow Function などすべての関数で共通する性質

1. printX の関数スコープに変数 x が定義されていない
2. ひとつ外側のスコープ（グローバルスコープ）を確認する
3. ひとつ外側のスコープに const x = 10;が定義されているので、識別子 x はこの変数を参照する

### 動的スコープ

- JS は静的スコープだから動的にはならない
- this というキーワードだけは動的に参照先が変わるよ

### メモリ管理の仕組み

- JS で不要なデータをメモリから解放する方法は？
  - ガベージコレクション
  - 自動的にメモリ上から解放する仕組み
- `let count = 0;`の count を誰かが引き受けた場合
  - `count` は解放される，`0`は誰かが引き受けてるときに参照するので解放されない
- `let count = 0;`の count を誰も引き受けなかった場合
  - `count` も `0`も両方解放
- 文字列とか配列オブジェクトとかを参照している変数が解放される
  - データの解放です！！！
- そのデータがメモリ上から解放されるかどうかは「そのデータが参照されているか」によって決定される
  - 関数の実行が終了したかどうかは直接関係はない ✨️

```js
let x = "before text";
// 変数`x`に新しいデータを代入する
x = "after text";
// このとき"before text"というデータはどこからも参照されなくなる
// その後、ガベージコレクションによってメモリ上から解放される
```

```js
function printX() {
  const x = "X";
  console.log(x); // => "X"
}

printX();
// この時点で`"X"`を参照するものはなくなる -> 解放される
```

```js
function createArray() {
  const tempArray = [1, 2, 3];
  return tempArray;
}
const array = createArray();
console.log(array); // => [1, 2, 3]
// 変数`array`が`[1, 2, 3]`という値を参照している -> 解放されない
```

### クロージャーがなぜ動くのか

- わからないこと
  - クロージャーは「静的スコープ」と「参照され続けている変数のデータが保持される」という 2 つの性質によって成り立っています。
  - この静的スコープとクロージャーの関係がちょっと曖昧
- 関数が特定の変数を参照することで関数が状態を持っている
  - 状態とは？

### クロージャーの用途

- クロージャーとなる関数の作り方とは？
  - ??? - X 変数が Y 関数の定義を参照 →X の実行した結果を Z 変数に代入 →Z 変数を実行

この形 👇️ これがクロージャで、B が維持される状態と思えば OK らしい

```js
function A {
    let B;
    return function C()
    { こねこね B;
    } }
```

### メモ

- 「変数と宣言」ページにその辺りの変数宣言方法の違い
- ECMAScript
  - エクマスクリプト
- 人が一度に把握できる範囲のサイズに処理をまとめていくこと
  - 処理を関数にまとめるという手法がよく利用される
- 即時実行関数はコラムなので一旦飛ばす

- 識別子とは？

  - 識別子は「名前」のこと
  - 変数名、関数名、パラメーター名、プロパティ名など
  - プログラム中の値や機能を指し示すラベルを指す
  - `function printX(){...}` なら `printX` が識別子
  - `const x = 0`なら`x`が識別子

- 高階関数とは？
  - 関数を返す関数のことを
